Day 1:

on submit - validate 
----------------------
toate inputurile completate
parola === confirm password si min 6 char, max 10 char
email = format tip email
checkboxurile - checked
username = 6 char min
eroare pe inputul cu probleme (color: red)

on save
----------------------
if (validate)

user {
    id: GUID,
    userName: '',
    userPwd: '',
    userEmail: ''
}

Daca Signup valid > redirect Login (to do de aici)

Day 2: 

Login:

Request la backend sa aduc toate datele
Iterare dbjson/users 
Scoatere user (obiect din array) in caz ca username/pass coincid
Daca nu exista user - afiseaza eroare sub form ca user nu exista sau parola este incorecta
Dupa ce s-a gasit user, baga in localStorage
Redirect spre dashboard (componenta)

Day 3: 

o pagina cu lista publicatiilor
fiecare item din lista respectiva afiseaza nume publicatie si data aparitiei
si are un buton, "Details"
cand apesi pe "Details"
mergi pe pagina de detalii a publicatiei
unde vezi toate detaliile
despre publicatie
si daca a fost marcata cu "allowReview"(sau cum se numea booleanul ala) o sa se poata lasa reviewuri si o sa se poata da stele

Router - check how to dymamic stuff
Details page: request backend pentru detaliul respectiva


Remake cu Router
Form pentru autori:
name / date of birth / photo / select > prepopulat cu nume de publisheri (on save sa ramana in baza de date id-ul publisherului, nu numele) / allow reviews




















 // const exactID = this.props.match.params.id;
          // const arrayOfID = this.state.publication;

          // const desiredPublication = (exactID, arrayOfID) => {
          //   for (let i = 0; i < arrayOfID.length; i++) {
          //     if (arrayOfID[i].id === exactID) {
          //       console.log(arrayOfID[i]);
          //       return arrayOfID[i];
          //     }
          //   }
          // };

          // --------------------------------

          // if (this.props.match.params.id) {
          //   this.setState({
          //     pubName: this.state.publication.pubName,
          //     pubDescription: this.state.publication.pubDescription,
          //     pubCeo: this.state.publication.pubCeo,
          //     pubLogo: this.state.publication.pubLogo,
          //     pubCeoImg: this.state.publication.pubCeoImg,
          //     publisherDate: this.state.publication.publisherDate,
          //     publisherChk: this.state.publication.publisherChk,
          //   });
          // }
        }
        // Remake function with router
        // () => {
        //   const currUrl = window.location.pathname;
        //   const splitUrl = currUrl.split("/");
        //   const urlID = splitUrl[2];
        //   // console.log(urlID);
        //   const search = (urlID, publication) => {
        //     for (let i = 0; i < publication.length; i++) {
        //       if (publication[i].id === urlID) {
        //         return publication[i];
        //       }
        //     }
        //   };
        //   const resultID = search(urlID, this.state.publication);
        //   // console.log(resultID);
        //   this.setState(
        //     {
        //       publication: resultID,
        //     },
        //     () => {
        //       if (urlID === resultID.id) {
        //         console.log("egalite, fraternite");
        //         // console.log(this.state.publication);
        //         this.setState({
        //           pubName: this.state.publication.pubName,
        //           pubDescription: this.state.publication.pubDescription,
        //           pubCeo: this.state.publication.pubCeo,
        //           pubLogo: this.state.publication.pubLogo,
        //           pubCeoImg: this.state.publication.pubCeoImg,
        //           publisherDate: this.state.publication.publisherDate,
        //           publisherChk: this.state.publication.publisherChk,
        //         });
        //       }
        //     }
        //   );
        // }